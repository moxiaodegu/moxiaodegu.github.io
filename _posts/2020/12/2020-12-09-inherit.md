---
title: 理解继承
tags: JavaScript
layout: post
---

# 继承

继承是通过原型链实现的,实例使用原型的属性和方法属于一种继承

## 原型和继承的关系

- instanceof 如果原型链出现过这个构造函数，则返回true
- isPrototypeOf 原型方法，判断原型是否包含这个实例

## 原型链导致的继承问题

- 原型包含引用值的时候，引用值在实例之间共享。 解决办法：盗用构造函数
- 子类型实例不能给父类型构造函数传参数

## 盗用构造函数

为了解决原型链引用值全局使用的问题，技术社区流行了一种叫做盗用构造函数的技术

### 基本原理

在子类构造函数中调用父类构造函数，可以使用apply 或者 call函数执行构造函数

这样的话，父类构造函数在子类的上下文执行了，原理和构造函数模式一样，每次创建实例都会在新的实例上定义一遍父类构造函数的方法

```javascript
    function SuperType() {
      this.colors = ["red", "blue", "green"];
    }
    function SubType() {
      //继承SuperType
      SuperType.call(this);
    }
    let instance1 = new SubType();
    instance1.colors.push("black");
    console.log(instance1.colors); // "red, blue, green, black"
    let instance2 = new SubType();
    console.log(instance2.colors); // "red, blue, green"
```

### 优点

相比于原型链，盗用构造函数最大的优点就是可以给父类构造函数传递参数

```javascript
    // 像父类构造函数传递参数
    function SuperType(name){
      this.name = name;
    }
    function SubType() {
      // 继承SuperType并传参
      SuperType.call(this, "Nicholas");
      // 实例属性
      this.age = 29;
    }
    let instance = new SubType();
    console.log(instance.name); // "Nicholas";
    console.log(instance.age);   // 29
```

### 缺点

- 和构造函数模式一样，缺点就是只能在构造函数中定义方法，因此函数不能重复使用，每次创建实例都会创建新的函数
- 子类不能访问父类构造函数的方法

### 组合继承（伪经典继承）

组合继承 顾名思义，组合了原型链继承和盗用构造函数，结合了两者的优点

不需要实例共享的，放在盗用构造函数里面，需要共享的放在实例的原型里面

```javascript
    function SuperType(name){
      this.name = name;
      this.colors = ["red", "blue", "green"];
    }
    SuperType.prototype.sayName = function() {
      console.log(this.name);
    };
    function SubType(name, age){
      // 继承属性
      SuperType.call(this, name);
      this.age = age;
    }
    // 继承方法
    SubType.prototype = new SuperType();
    SubType.prototype.sayAge = function() {
      console.log(this.age);
    };
    let instance1 = new SubType("Nicholas", 29);
    instance1.colors.push("black");
    console.log(instance1.colors);   // "red, blue, green, black"
    instance1.sayName();               // "Nicholas";
    instance1.sayAge();                // 29
    let instance2 = new SubType("Greg", 27);
    console.log(instance2.colors);   // "red, blue, green"
    instance2.sayName();               // "Greg";
    instance2.sayAge();                // 27
```
## 原型式继承





