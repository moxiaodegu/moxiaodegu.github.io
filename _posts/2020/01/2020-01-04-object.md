---
title: Object
tags: JavaScript
layout: post
---

## object

- object 数值属性会自动转化成字符串
- 在使用字面量表示定义对象的时候，并不会实际调用Object构造函数
- object是基础类型，所有引用类型都继承了它的基本行为

## Object.defineProperty() 和 Object.defineProperties()

- Object.defineProperties(obj, props) 直接在一个对象上定义新的属性或修改现有属性，并返回该对象。

```javascript
    var obj = {};
    Object.defineProperties(obj, {
    'property1': {
        value: true,
        writable: true
    },
    'property2': {
        value: 'Hello',
        writable: false
    }
    // etc. etc.
    });
```

![20210831124806](https://cdn.jsdelivr.net/gh/moxiaodegu/ImageHosting/imagesBlogs/20210831124806.png)

- Object.defineProperty(obj, prop, descriptor) 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

```javascript
    const object1 = {};

    Object.defineProperty(object1, 'property1', {
    value: 42,
    writable: false
    });

    object1.property1 = 77;
    // throws an error in strict mode

    console.log(object1.property1);
    // expected output: 42
```

## 创建object

1. var obj = {}  
   var obj = new Object()
2. Object.create()
   1. Object.create(proto,[propertiesObject])
      1. proto 没有的话传入null，原型为null，
      2. {} === Object.create(Object.prototype)
      3. propertiesObject参数选。类似于Object.defineProperties(obj, props)第二个参数

         ```javascript
            // 创建一个以另一个空对象为原型,且拥有一个属性p的对象
            o = Object.create({}, { p: { value: 42 } })

            // 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:
            o.p = 24
            o.p
            //42

            o.q = 12
            for (var prop in o) {
            console.log(prop)
            }
            //"q"

            delete o.p
            //false

            //创建一个可写的,可枚举的,可配置的属性p
            o2 = Object.create({}, {
            p: {
                value: 42,
                writable: true,
                enumerable: true,
                configurable: true
            }
            });
         ```

   2. 用于继承一个对象，并添加到原型链中
3. 构造函数模式

   ```javascript
    function ObjCur(name, age) {
        this.name = name;
        this.age = age;
    }
    var obj = new ObjCur('limi', 30)
   ```

4. 工厂模式
5. 原型模式

## 枚举一个 object 的所有属性

> 枚举顺序 数值键 字符串键 symbol

1. for...in 枚举一个对象及其原型链中所有可枚举属性

    ```javascript
    for(let i in objectName) {
        if (objectName.hasOwnProperty(i)) { // 只关注自身属性

        }
    }
    ```

2. Object.keys(objectName) 返回对象自身（不包含原型链）的所有可枚举属性名称的数组
3. Object.getOwnPropertyNames(objectName) 返回对象自身（不包含原型链）的所有可枚举不可枚举的属性名称的值
4. Object.values(objName) 返回自身（不包含继承）属性的所有值的数组
5. Object.entries(objName) 返回自身 key value 的二级数组

    ```javascript
    for(let [key,value] of Object.entries(obj1)){
        console.log(`key: ${key} value:${value}`)
    }
    ```

6. Object.getOwnPropertyDescriptors(obj) 返回所有自身属性描述符

## 继承

- js对象最少继承一个对象，被继承的对象称为原型，可通过构造函数prototype找到

## getters 和 setters

- 初始化

    ```javascript
        var o = {
            a: 7,
            get b() { return this.a + 1; },
            set c(x) { this.a = x / 2; }
        };
    ```

- Object.defineProperties
  
    ```javascript
        Object.defineProperties(o, {
            "b": { get: function () { return this.a + 1; } },
            "c": { set: function (x) { this.a = x / 2; } }
        });
    ```

## 删除object

- delete

## 比较对象 Object.is(value1, value2); // 返回Boolean

- js中 对象是引用类型，两个独立声明的对象永远也不会相等
  
    ```javascript
    let obj = new Object()
    let obj1 = new Object()
    obj === obj1 // false
    ```

- Object.is(value1, value2) 和 === 非常像

## 合并对象 Object.assign(a,b)

> 该方法接收多个参数，第一个参数为目标对象，后面多个参数为源对象，源对象中可枚举（Object.propertyIsEnumerable()返回true）且 自有（Object.hasOwnProperty()返回true）的属性复制到目标对象，并返回这个对象。复制原理其实就是调用源对象的[get]方法获取到符合条件的属性，调用目标对象的[set]方法保存到目标对象

特点：

- 浅拷贝
- 相同属性名后面的值覆盖前面的值

如：Object.assign(a,b)合并b对象到a,返回合并后对象，相同键名后面覆盖前面，浅拷贝，引用类型数据拷贝的是可枚举属性值。

## es6新增语法糖

- 对象属性简写

    ```javascript
    const name='Ming',age='18',city='Shanghai';

    // es5
    const student = {
        name: name,
        age:age,
        city:city
    };

    // es6     
    const student = {
        name,
        age,
        city
    };
    console.log(student); // {name: "Ming", age: "18", city: "Shanghai"}
    ```

- 简写方法名

  ```javascript
    // es5
    const obj = {
        sayName: function (name) {
            console.log(name)
        }
    }
    // es6
    const obj = {
        sayName(name) {
            console.log(name)
        }
    }
  ```

- 可计算属性

    ```javascript
        const name = "limei"
        const name1 = "limei1"
        const obj = {
            [name1]:"999"
            [name](){

            }
        }

        // {limei:"matt"}
    ```

- 对象解构

    > null 和 undefined 不可以被解构
    > 浅拷贝

    ```javascript
        const obj = {name: "test",age:"22"}
        const {name,age:age1} = obj
        console.log(name) // test
        console.log(age1) // 22
        // 结构不要求变量在结构表达式中声明，但是事先声明的标量复制，要包含在一对括号里面去
        let personName,personAge;
        const obj = {
            name:"person",
            age:"22"
        }
        ({name:personName,age:personAge} = obj)
        
        // 如果a对象想要b对象的部分属性
        let a = {}
        let b = {
            name: "tast",
            age: "22",
            ...
        }
        ({name:b.name} = a)
    ```

  - 嵌套解构
  
     > 外层属性没有定义的情况下不可以使用嵌套语句

    ```javascript
        const obj = {
            name:"test",
            age:"22",
            friends: {
                title: "tit"
            }
        }
        let {friends: person} = obj 
        // obj的friends属性的值是引用类型,如果修改person会影响到obj的属性

        person.title = "浅拷贝"
        console.log(obj.friends) // 浅拷贝

        // 嵌套属性结构
        let {friends: {title} } = obj // 创建一个title变量并赋值obj.friends.title
        let {friends: {title：tit } = obj // 创建一个tit变量并赋值obj.friends.title

    ```

  - 部分解构

    - 如果多个解构，解构成功一部分后解构失败，只能成功一部分
  
  - 参数上下文匹配
    - 函数参数也可以参与解构
