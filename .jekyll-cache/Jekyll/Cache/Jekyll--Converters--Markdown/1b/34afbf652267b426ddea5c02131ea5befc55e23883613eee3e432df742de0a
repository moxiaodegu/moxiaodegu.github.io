I"H<p>在上一篇文章【<a href="https://limeii.github.io/2019/05/js-execution-context/">JS：深入理解JavaScript-执行上下文</a>】中介绍了执行上下文是如何工作的。在这篇文章里会介绍执行上下文中的ThisBinding，也就是JavaScript中的this。</p>

<p>有四种可执行代码可以创建执行上下文，分别是<code class="language-plaintext highlighter-rouge">global code</code> <code class="language-plaintext highlighter-rouge">function code</code> <code class="language-plaintext highlighter-rouge">module</code>和<code class="language-plaintext highlighter-rouge">eval code</code>。接下来分别介绍这<code class="language-plaintext highlighter-rouge">global code</code> <code class="language-plaintext highlighter-rouge">function code</code>可执行代码中的this（ThisBinding）到底指的是什么。</p>

<h2 id="global-code的this">global code的this</h2>

<p>在JS引擎运行global code之前，会创建一个全局执行上下文压入执行栈的栈底，这个全局执行上文的ThisBinding绑定的是全局对象，在浏览器里指的就是window。</p>

<h2 id="function-code的this">function code的this</h2>
<p>在文章【<a href="https://limeii.github.io/2019/05/js-lexical-environment/">JS：深入理解JavaScript-词法环境</a>】提到过JavaScript是静态作用域，词法环境是由代码结构决定的，开发把代码写成什么样，词法环境就是怎么样，跟方法在哪里调用没有关系。但是对于函数的this刚好反过来，跟代码在哪里定义没有关系，而跟代码在哪里调用有关系。一般我们调用函数有以下四种方式：</p>

<ul>
  <li>普通函数调用，比如foo()或者(functon(){})()</li>
  <li>作为对象方法调用，比如obj.foo()</li>
  <li>构造函数调用，比如new foo()</li>
  <li>使用call、apply、bind等方法调用</li>
</ul>

<p>在介绍着几种函数调用之前，我们先来看下ECMAScript对this的规范：</p>

<blockquote>
<p>
ECMAScript规范： 严格模式时，函数内的this绑定严格指向传入的thisArgument。非严格模式时，若传入的thisArgument不为undefined或null时，函数内的this绑定指向传入的thisArgument；为undefined或null时，函数内的this绑定指向全局的this。
</p>
</blockquote>

<h3 id="普通函数调用">普通函数调用</h3>
<p>普通函数的调用，包括函数调用foo()和立即调用函数表达式(functon(){})()，传到函数里的thisArgument是undefined。根据ECMAScript规范，如果在非严格模式下，普通函数里的this就是全局对象，而在严格模式下就为undefined。</p>

<p>比如有以下代码：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">//2</span>
</code></pre></div></div>
<p>如果把foo方法改为严格模式：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">();</span>
</code></pre></div></div>
<p>执行上面这段代码，会报错：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VM162:4 Uncaught TypeError: Cannot read property 'a' of undefined
    at foo (&lt;anonymous&gt;:4:22)
</code></pre></div></div>

<h3 id="对象方法调用">对象方法调用</h3>
<p>作为对象方法调用，传到函数里的thisArgument是该对象。比如有如下代码：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
	<span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">//2</span>
</code></pre></div></div>
<p>需要注意的是，只有离函数最近的这个对象，才是该函数的this，比如有代码：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">a</span><span class="p">:</span> <span class="mi">42</span><span class="p">,</span>
	<span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
	<span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
	<span class="na">obj2</span><span class="p">:</span> <span class="nx">obj2</span>
<span class="p">};</span>

<span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">//42</span>
</code></pre></div></div>
<p>还有一种比较看起来像对象方法调用，实际上是普通函数调用：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span> 
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">global variable</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">bar</span><span class="p">();</span> <span class="c1">// global variable</span>
</code></pre></div></div>

<h3 id="构造函数调用">构造函数调用</h3>
<p>new functionname()构造函数调用，this指的是构造出来的新对象。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">foo</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<h3 id="使用callapplybind等方法调用">使用call、apply、bind等方法调用</h3>
<p>call、apply、bind调用，可以显示传递对象给函数的thisArg，默认这几个函数的第一个形参是thisArg:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span> <span class="nx">thisArg</span><span class="p">,</span> <span class="nx">argArray</span> <span class="p">)</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span> <span class="nx">thisArg</span> <span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="p">[</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...</span> <span class="p">]</span> <span class="p">)</span>
<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span> <span class="nx">thisArg</span> <span class="p">,</span> <span class="p">[</span> <span class="nx">arg1</span><span class="p">,</span> <span class="p">[</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...</span> <span class="p">]</span> <span class="p">]</span> <span class="p">)</span>
</code></pre></div></div>
<p>需要注意的是当thisArg为null或者undefined，在非严格模式下，this是全局对象。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="kd">function</span> <span class="nx">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">print</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span><span class="c1">//window</span>
<span class="nx">print</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span><span class="c1">//window</span>
<span class="nx">print</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span><span class="c1">//obj</span>
</code></pre></div></div>

<h2 id="箭头函数的this">箭头函数的this</h2>
<p>箭头函数在调用的时候不会绑定this，它会去词法环境链上寻找this，所以箭头函数的this取决于它定义的位置（包裹箭头函数的第一个普通函数的this）。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span> <span class="c1">// 10</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="nx">foo</span>
<span class="p">}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">()</span> <span class="c1">//10</span>

<span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="p">()</span>
<span class="p">}</span>
<span class="nx">bar</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span> <span class="c1">//10</span>
</code></pre></div></div>

<h2 id="回调函数的this">回调函数的this</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
    <span class="na">foo</span><span class="p">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//10</span>

</code></pre></div></div>
<p>上面代码运行结果是10，作为回调函数的时候，传递的是函数体，并不是函数名。在执行栈里，obj.foo已经执行完成被弹出执行栈，此时执行栈里只有全局执行上下文，setTimeout回调函数体执行的时候this为全局对象。</p>

<p>要想避免这种情况，有两种方法，第一种方法是使用bind返回的指定好this绑定的函数作为回调函数传入：</p>

<ul>
  <li>使用bind指定this
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">bind</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">20</span><span class="p">}),</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 20</span>
</code></pre></div>    </div>
  </li>
  <li>使用箭头函数
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">arrowFn</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="na">a</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span>
<span class="nx">arrowFn</span><span class="p">()</span> <span class="c1">// 20</span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">arrowFn</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">//20</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="总结">总结</h2>

<ul>
  <li>
    <p>箭头函数中没有this绑定，this的值取决于其创建时所在词法环境链中最近的this绑定</p>
  </li>
  <li>
    <p>非严格模式下，函数普通调用，this指向全局对象</p>
  </li>
  <li>
    <p>严格模式下，函数普通调用，this为undefined</p>
  </li>
  <li>
    <p>函数作为对象方法调用，this指向该对象</p>
  </li>
  <li>
    <p>函数作为构造函数配合new调用，this指向构造出的新对象</p>
  </li>
  <li>
    <p>非严格模式下，函数通过call、apply、bind等间接调用，this指向传入的第一个参数, 传入的第一个参数若为undefined或null，this指向全局对象</p>
  </li>
  <li>
    <p>格模式下函数通过call、apply、bind等间接调用，this严格指向传入的第一个参数</p>
  </li>
</ul>
:ET