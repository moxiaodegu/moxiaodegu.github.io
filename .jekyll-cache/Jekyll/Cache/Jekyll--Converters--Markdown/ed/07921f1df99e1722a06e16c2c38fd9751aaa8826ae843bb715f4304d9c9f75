I"}<h2 id="1枚举对象属性">1.枚举对象属性</h2>
<p>有三种原生的方法可以列出或者枚举对象的属性。</p>

<ul>
  <li>for…in循环，该方法会依次访问一个对象以及其原型链中所有可枚举的属性</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="na">d</span><span class="p">:</span> <span class="mi">4</span>
<span class="p">}</span>

<span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">proptery</span> <span class="k">in</span> <span class="nx">obj2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">proptery is </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">proptery</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> value is </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">obj2</span><span class="p">[</span><span class="nx">proptery</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">//result:</span>
<span class="c1">//proptery is e value is 5</span>
<span class="c1">//proptery is a value is 1</span>
<span class="c1">//proptery is b value is 2</span>
<span class="c1">//proptery is c value is 3</span>
<span class="c1">//proptery is d value is 4</span>
</code></pre></div></div>

<ul>
  <li>Object.keys(o)，该方法返回对象自身（不包括原型中）的所有属性的名称的数组。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="na">d</span><span class="p">:</span> <span class="mi">4</span>
<span class="p">}</span>

<span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj2</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span> <span class="c1">// ["e","f"]</span>
</code></pre></div></div>

<ul>
  <li>Object.getOwnPropertyNames(o)，该方法返回一个数组，它包好了对象o所有的属性（无论是否可枚举）的名称。</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="na">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="na">d</span><span class="p">:</span> <span class="mi">4</span>
<span class="p">}</span>

<span class="nx">obj2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">e</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">items</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">obj2</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span> <span class="c1">// ["e","f"]</span>
</code></pre></div></div>

<h2 id="2-判断对象是否为空">2. 判断对象是否为空</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isEmpty</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">pro</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">pro</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({});</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">isEmpty</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Object</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-原始类型primitivevs-对象object">3. 原始类型（Primitive）vs 对象（Object）</h2>
<p>原始类型有6种：<code class="language-plaintext highlighter-rouge">undefined</code> <code class="language-plaintext highlighter-rouge">null</code> <code class="language-plaintext highlighter-rouge">string</code> <code class="language-plaintext highlighter-rouge">number</code> <code class="language-plaintext highlighter-rouge">boolean</code> <code class="language-plaintext highlighter-rouge">symbol</code>.</p>

<p>除了原始值之外的都是对象。两者的区别是：原始值存储的是值，对象存储的是指针。原始值没有方法的，<code class="language-plaintext highlighter-rouge">undefined.toString()</code>会报错，但是<code class="language-plaintext highlighter-rouge">'1'.toString()</code>可以是因为把’1‘强制转换成了<code class="language-plaintext highlighter-rouge">String</code>对象。</p>

<p>由于对象保存的是引用，那么当把一个对象赋值给另一个对象的时候也是拷贝引用，两个对象的引用指向的是同一个地址，该其中的一个值，会影响另外一个值。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">test</span><span class="p">(</span><span class="nx">person</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">26</span>
  <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">yyy</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">30</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">person</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">yck</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">25</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">p2</span> <span class="o">=</span> <span class="nx">test</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">)</span> <span class="c1">// -&gt; ?</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p2</span><span class="p">)</span> <span class="c1">// -&gt; ?</span>
</code></pre></div></div>

<ul>
  <li>首先，函数传参是传对对象的指针的副本</li>
  <li>到函数内部修改参数的属性这步，当前p1的值也被修改了</li>
  <li>但是当我们重新为person分配一个对象时，会发生什么呢？请看下图：</li>
</ul>

<p><img src="/assets/images/posts/js/js-common04.png" alt="js-common" height="100%" width="100%" /></p>

<p>所以最后 person 拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的。</p>

<h2 id="4-typeof-vs-instanceof">4. typeof vs instanceof</h2>
<p>typeof 对于原始值类型来说，除了 null 都可以显示正确的类型：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="mi">42</span><span class="p">;</span>                  <span class="c1">// "number"</span>
<span class="k">typeof</span> <span class="dl">"</span><span class="s2">abc</span><span class="dl">"</span><span class="p">;</span>               <span class="c1">// "string"</span>
<span class="k">typeof</span> <span class="kc">true</span><span class="p">;</span>                <span class="c1">// "boolean"</span>
<span class="k">typeof</span> <span class="kc">undefined</span><span class="p">;</span>           <span class="c1">// "undefined"</span>
<span class="k">typeof</span> <span class="kc">null</span><span class="p">;</span>                <span class="c1">// "object" -- oops, JS bug!</span>
<span class="k">typeof</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>          <span class="c1">// "object"</span>
<span class="k">typeof</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>             <span class="c1">// "object"</span>
<span class="k">typeof</span> <span class="kd">function</span> <span class="nx">Hello</span><span class="p">(){};</span>  <span class="c1">// "function"</span>
</code></pre></div></div>
<p>typeof 对于对象来说，除了函数，都会显示成 object：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="p">[]</span> <span class="c1">// 'object'</span>
<span class="k">typeof</span> <span class="p">{}</span> <span class="c1">// 'object'</span>
<span class="k">typeof</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span> <span class="c1">// 'function'</span>
</code></pre></div></div>
<p>如果我们想要判断一个正确的对象类型，就需要用 instanceof，它的内部机制是通过原型链来判断的：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Person</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
<span class="kd">const</span> <span class="nx">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">()</span>
<span class="nx">p1</span> <span class="k">instanceof</span> <span class="nx">Person</span> <span class="c1">// true</span>

<span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span>
<span class="nx">str</span> <span class="k">instanceof</span> <span class="nb">String</span> <span class="c1">// false</span>

<span class="kd">var</span> <span class="nx">str1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">str1</span> <span class="k">instanceof</span> <span class="nb">String</span> <span class="c1">// true</span>

</code></pre></div></div>

<h3 id="instanceof-的原理">instanceof 的原理</h3>

<p>instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</p>

<p>我们也可以试着实现一下 instanceof</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">myInstanceof</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">prototype</span> <span class="o">=</span> <span class="nx">right</span><span class="p">.</span><span class="nx">prototype</span>
  <span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">.</span><span class="nx">__proto__</span>
  <span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">left</span> <span class="o">===</span> <span class="kc">null</span> <span class="o">||</span> <span class="nx">left</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">prototype</span> <span class="o">===</span> <span class="nx">left</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="p">.</span><span class="nx">__proto__</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>以下是对实现的分析：</p>

<ul>
  <li>首先获取类型的原型</li>
  <li>然后获得对象的原型</li>
  <li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li>
</ul>

<h2 id="5-类型转换">5. 类型转换</h2>
<p>在 JS 中类型转换只有三种情况：</p>
<ul>
  <li>转换为布尔值</li>
  <li>转换为数字</li>
  <li>转换成字符串</li>
</ul>

<p>先来看第一种转换：</p>

<p><img src="/assets/images/posts/js/js-common05.png" alt="js-common" height="100%" width="100%" /></p>

<blockquote>
<p>
注意图中有一个错误，Boolean 转字符串这行结果我指的是 true 转字符串的例子，不是说 Boolean、函数、Symblo 转字符串都是 `true`
</p>
</blockquote>

<h3 id="转为boolean值">转为boolean值</h3>
<p>在条件判断时，除了 undefined， null， false， NaN， ‘‘， 0， -0，其他所有值都转为 true，包括所有对象。</p>

<h2 id="6-四则运算符">6. 四则运算符</h2>
<p>加法运算符不同于其他几个运算符，它有以下几个特点：</p>

<p>运算中其中一方为字符串，那么就会把另一方也转换为字符串</p>

<p>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="c1">// '11'</span>
<span class="kc">true</span> <span class="o">+</span> <span class="kc">true</span> <span class="c1">// 2</span>
<span class="mi">4</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c1">// "41,2,3"</span>
</code></pre></div></div>

<p>如果你对于答案有疑问的话，请看解析：</p>

<ul>
  <li>
    <p>对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 ‘11’</p>
  </li>
  <li>
    <p>对于第二行代码来说，触发特点二，所以将 true 转为数字 1</p>
  </li>
  <li>
    <p>对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3</p>
  </li>
</ul>

<p>另外对于加法还需要注意这个表达式 ‘a’ + + ‘b’</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span> <span class="o">+</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span> <span class="c1">// -&gt; "aNaN"</span>
</code></pre></div></div>
<p>因为 + ‘b’ 等于 NaN，所以结果为 “aNaN”，你可能也会在一些代码中看到过 + ‘1’ 的形式来快速获取 number 类型。</p>

<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">4</span> <span class="o">*</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span> <span class="c1">// 12</span>
<span class="mi">4</span> <span class="o">*</span> <span class="p">[]</span> <span class="c1">// 0</span>
<span class="mi">4</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c1">// NaN</span>
</code></pre></div></div>

<h2 id="6--vs-">6. == vs ===</h2>

<p>对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换，这也就用到了我们上一章节讲的内容。</p>

<p>假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程：</p>

<ul>
  <li>首先会判断两者类型是否相同。相同的话就是比大小了</li>
  <li>类型不相同的话，那么就会进行类型转换</li>
  <li>会先判断是否在对比 null 和 undefined，是的话就会返回 true</li>
  <li>判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span>
      <span class="err">↓</span>
<span class="mi">1</span> <span class="o">==</span>  <span class="mi">1</span>
</code></pre></div></div>

<p>判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span> <span class="kc">true</span>
        <span class="err">↓</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span>  <span class="mi">1</span>
        <span class="err">↓</span>
 <span class="mi">1</span>  <span class="o">==</span>  <span class="mi">1</span>
</code></pre></div></div>

<p>判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">yck</span><span class="dl">'</span> <span class="p">}</span>
        <span class="err">↓</span>
<span class="dl">'</span><span class="s1">1</span><span class="dl">'</span> <span class="o">==</span> <span class="dl">'</span><span class="s1">[object Object]</span><span class="dl">'</span>
</code></pre></div></div>

<p>对于 === 来说就简单多了，就是判断两者类型和值是否相同。需要注意的是有两个特殊情况：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span><span class="p">;</span>            <span class="c1">// false</span>
<span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span><span class="p">;</span>               <span class="c1">// true</span>
</code></pre></div></div>
<p>对于<code class="language-plaintext highlighter-rouge">NaN</code>的比较，用<code class="language-plaintext highlighter-rouge">Number.isNaN()</code>；对于<code class="language-plaintext highlighter-rouge">-0</code>的比较，用<code class="language-plaintext highlighter-rouge">Object.is()</code>。</p>

<h2 id="7-map-filter-reduce">7. map, filter, reduce</h2>

<p>map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// -&gt; [2, 3, 4]</span>
</code></pre></div></div>

<p>另外 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">)</span>
<span class="c1">//第一轮遍历 parseInt('1', 0) -&gt; 1</span>
<span class="c1">//第二轮遍历 parseInt('2', 1) -&gt; NaN</span>
<span class="c1">//第三轮遍历 parseInt('3', 2) -&gt; NaN</span>
</code></pre></div></div>
<p>filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="o">!==</span> <span class="mi">6</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newArray</span><span class="p">)</span> <span class="c1">// [1, 2, 4]</span>
</code></pre></div></div>

<p>和 map 一样，filter 的回调函数也接受三个参数，用处也相同。</p>

<p>最后我们来讲解 reduce 这块的内容，同时也是最难理解的一块内容。reduce 可以将数组中的元素通过回调函数最终转换为一个值。</p>

<p>如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">total</span> <span class="o">+=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">total</span><span class="p">)</span> <span class="c1">//6 </span>
</code></pre></div></div>
<p>但是如果我们使用 reduce 的话就可以将遍历部分的代码优化为一行代码</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
</code></pre></div></div>

<p>对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程</p>

<ul>
  <li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</li>
  <li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</li>
  <li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</li>
  <li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6</li>
</ul>

<p>想必通过以上的解析大家应该明白 reduce 是如何通过回调函数将所有元素最终转换为一个值的，当然 reduce 还可以实现很多功能，接下来我们就通过 reduce 来实现 map 函数</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="kd">const</span> <span class="nx">mapArray</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">reduceArray</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">acc</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">current</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">acc</span>
<span class="p">},</span> <span class="p">[])</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mapArray</span><span class="p">,</span> <span class="nx">reduceArray</span><span class="p">)</span> <span class="c1">// [2, 4, 6]</span>
</code></pre></div></div>

<h2 id="如何判断相等性">如何判断相等性</h2>

:ET