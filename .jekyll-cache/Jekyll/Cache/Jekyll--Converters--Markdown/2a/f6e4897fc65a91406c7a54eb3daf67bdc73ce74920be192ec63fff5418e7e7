I"C<p>JavaScript中定义函数有这几种方式：</p>
<ul>
  <li>函数声明</li>
  <li>函数表达式</li>
  <li>立即执行函数</li>
  <li>new Funcion(arg1,arg2…,argn,body)创建函数。</li>
</ul>

<p>定义函数的方式不同，它们的词法环境会不一样，作用域链也不一样。</p>

<h2 id="函数声明">函数声明</h2>

<p>我们来看一个函数声明的例子：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 2</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="nx">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">bar</span><span class="p">();</span>
</code></pre></div></div>
<p>在文章【<a href="https://limeii.github.io/2019/05/js-lexical-environment/">JS：深入理解JavaScript-词法环境</a>】提到过JavaScript是静态作用域，词法环境是由代码结构决定的，开发把代码写成什么样，词法环境就是怎么样，跟方法在哪里调用没有关系。在文章【<a href="https://limeii.github.io/2019/05/js-execution-context/">JS：深入理解JavaScript-执行上下文</a>】介绍了执行上下文会给每个方法创建词法环境。</p>

<p>我们来看下上面代码在创建执行上下文但是还没有被执行之前的词法环境：</p>

<p><img src="/assets/images/posts/js/js-function01.png" alt="js-function" height="100%" width="100%" /></p>

<p>函数<code class="language-plaintext highlighter-rouge">foo</code> <code class="language-plaintext highlighter-rouge">bar</code>都是函数声明，函数声明在创建词法环境的时候，会被初始化，所以上图<code class="language-plaintext highlighter-rouge">fooFunctionEnviroment</code>和<code class="language-plaintext highlighter-rouge">barFunctionEnviroment</code>都在内存中都已经初始化了，这就是我们所说的<strong>函数提升</strong>。</p>

<p>全局变量<code class="language-plaintext highlighter-rouge">var a=2</code>是变量声明，变量声明在创建词法环境的时候，会被初始化为undefined，所以上图中的<code class="language-plaintext highlighter-rouge">a=undefined</code>，这就是我们所说的<strong>变量提升</strong>。函数<code class="language-plaintext highlighter-rouge">bar</code>中的变量a也类似，只不过它被初始化在<code class="language-plaintext highlighter-rouge">barFunctionEnviroment</code>词法作用域里。</p>

<p>当执行完第一行代码<code class="language-plaintext highlighter-rouge">var a=2</code>，给全局变量a赋值，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function02.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行函数<code class="language-plaintext highlighter-rouge">bar()</code>里代码<code class="language-plaintext highlighter-rouge">var a=3</code>，给bar中的变量赋值，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function03.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行函数<code class="language-plaintext highlighter-rouge">foo()</code>里代码<code class="language-plaintext highlighter-rouge">console.log(a)</code>，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function04.png" alt="js-function" height="100%" width="100%" /></p>

<p>这时候发现在<code class="language-plaintext highlighter-rouge">fooFunctionEnviroment</code>词法环境里没有变量a，就会到它的上一层词法环境去找，<strong>函数的<code class="language-plaintext highlighter-rouge">scope</code>里记录了它上一层词法环境</strong>，foo函数的上一层词法环境是<code class="language-plaintext highlighter-rouge">GlobalEnvironment</code>全局词法环境，所以输出的是<code class="language-plaintext highlighter-rouge">2</code>而不是<code class="language-plaintext highlighter-rouge">3</code>。</p>

<p><strong>从上面的例子可以看出，对于函数声明，会有函数提升，函数的初始化发生在词法环境创建的时候，函数表达式的词法环境还是由代码结构决定的，开发把代码写成什么样，词法环境就是怎么样，跟方法在哪里调用没有关系。</strong></p>

<h2 id="函数表达式">函数表达式</h2>

<p>我们来看个函数表达式的例子：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nx">foo</span><span class="p">();</span> <span class="c1">//TypeError: foo is not a function</span>
<span class="nx">bar</span><span class="p">();</span> <span class="c1">//TypeError: bar is not a function</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bar</span><span class="p">);</span> <span class="c1">// undefined</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>

<span class="p">}</span>

<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">_bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span><span class="mi">4</span>
    <span class="nx">foo</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<p>我们可以看到不管是匿名函数表达式还是命名函数表达式，<code class="language-plaintext highlighter-rouge">foo</code> 和<code class="language-plaintext highlighter-rouge">bar</code>这两个变量有提升初始化为undefined，但是函数体并没有<strong>函数提升</strong>。</p>

<p>我们把代码改一下：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 2</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// Uncaught ReferenceError: b is not defined</span>

<span class="p">}</span>

<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">_bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span><span class="mi">4</span>
    <span class="nx">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">();</span>
</code></pre></div></div>
<p>运行上面代码，a输出的是全局变量a的值，全局变量里没有b，就报了ReferenceError。</p>

<p>我们来看下上面代码在创建执行上下文但是还没有被执行之前的词法环境：
<img src="/assets/images/posts/js/js-function05.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行完第一行代码<code class="language-plaintext highlighter-rouge">var a=2</code>，给全局变量a赋值，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function06.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行<code class="language-plaintext highlighter-rouge">bar()</code>，会给bar的函数表达式新创建一个执行上下文和词法环境，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function07.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行<code class="language-plaintext highlighter-rouge">foo()</code>，会给foo的函数表达式新创建一个执行上下文和词法环境，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function08.png" alt="js-function" height="100%" width="100%" /></p>

<p>这时候发现在<code class="language-plaintext highlighter-rouge">fooFunctionEnviroment</code>词法环境里没有变量a和b，就会到它的上一层词法环境去找，函数的<code class="language-plaintext highlighter-rouge">scope</code>里记录了它上一层词法环境，foo函数的上一层词法环境是<code class="language-plaintext highlighter-rouge">GlobalEnvironment</code>全局词法环境，所以输出的是<code class="language-plaintext highlighter-rouge">2</code>和<code class="language-plaintext highlighter-rouge">ReferenceError</code>。</p>

<p>我们再把上面的代码改一下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">_bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span><span class="mi">4</span>
    <span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 3</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// 4</span>
    
    <span class="p">}</span>
    <span class="nx">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">bar</span><span class="p">();</span>
</code></pre></div></div>
<p>运行上面代码，a输出的是bar中变量a和b的值。</p>

<p>我们来看下上面代码在创建执行上下文但是还没有被执行之前的词法环境：
<img src="/assets/images/posts/js/js-function09.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行完第一行代码<code class="language-plaintext highlighter-rouge">var a=2</code>，给全局变量a赋值，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function10.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行<code class="language-plaintext highlighter-rouge">bar()</code>，会给bar的函数表达式新创建一个执行上下文和词法环境，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function11.png" alt="js-function" height="100%" width="100%" /></p>

<p>当执行<code class="language-plaintext highlighter-rouge">foo()</code>，会给foo的函数表达式新创建一个执行上下文和词法环境，它的上一层词法环境是<code class="language-plaintext highlighter-rouge">barFunctionEnviroment</code>，此时的执行上下文和词法环境如下：
<img src="/assets/images/posts/js/js-function12.png" alt="js-function" height="100%" width="100%" /></p>

<p>在执行<code class="language-plaintext highlighter-rouge">foo()</code>，发现没有变量a和b，就到它的上一层词法环境<code class="language-plaintext highlighter-rouge">barFunctionEnviroment</code>去找，所以输出的是3和4。</p>

<p><strong>从上面的例子可以看出，对于函数表达式，它们的函数体不会函数提升，函数的初始化发生在代码执行的时候，函数表达式的词法环境还是由代码结构决定的，开发把代码写成什么样，词法环境就是怎么样，跟方法在哪里调用没有关系。</strong></p>

<h2 id="立即执行函数">立即执行函数</h2>

<p>立即执行函数和函数表达式是一样的，不会函数提升，函数的初始化发生在代码执行的时候，词法环境还是由代码结构决定的。</p>

<h2 id="new-funcionarg1arg2argnbody创建函数">new Funcion(arg1,arg2…,argn,body)创建函数</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">sum</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Function</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">return a + b+c</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">));</span> <span class="c1">//18</span>
</code></pre></div></div>

<p>用new Function(arg1,arg2,…,argn,body) 创建函数的过程有和上面函数表达式类似，不同地方在于，创建函数使用的scope是直接使用全局词法环境(glbal enviroment),而不管当前运行上下文，一律取全局词法环境(glbal enviroment)。</p>

<h2 id="思考题">思考题</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">foo</span><span class="p">);</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">foo</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>在这里会打印函数，而不是 undefined。</p>

<p>这是因为在进入执行上下文的时候，首先会处理函数声明，其次会处理变量声明，<strong>如果变量名称已经跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</strong></p>

<h2 id="总结">总结</h2>

<ul>
  <li>
    <p>函数声明，会有变量提升，函数初始化是发生在函数创建时运行上下文的词法环境里。</p>
  </li>
  <li>
    <p>函数表达式/匿名函数/立即执行函数，没有变量提升，函数初始化是发生在代码执行的时候。</p>
  </li>
  <li>
    <p>函数的词法环境中的scope，是用来记录上一层的词法环境。</p>
  </li>
  <li>
    <p>如果函数有形参，那么这些形参都属于函数的词法环境。</p>
  </li>
</ul>

:ET