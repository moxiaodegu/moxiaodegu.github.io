I"[`<p>JavaScript是单线程的，正是因为有异步处理，JS才不会卡顿，JS的异步处理方式有：</p>

<p><strong>回调函数 -&gt; Promise -&gt; Generator -&gt; Async</strong></p>

<p>之前一直很困惑，为什么JS异步处理方式有这么多种，Promise能解决大部分实际开发工作中的异步处理。看完Generator和Async的具体用法之后，才恍然大悟，从回调函数到Promise到Generator再到Async，其实也是想让异步代码可读性要好一点，异步代码写得越来越像同步代码，这应该是异步处理的终极目标吧。</p>

<p>接下来就分别用这四种方式来实现同一个异步调用，看看这四种方式实现异步处理各有什么优劣。在示例代码里会用API：【<a href="https://developer.github.com/v3/search/#search-users">Github Search user API</a>】，先根据关键字搜索Github用户，然后根据返回的搜索结果得到搜索结果的数量。</p>

<h2 id="回调函数">回调函数</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">https</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">https</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">cbGetGitUser</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">https</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.github.com/search/users?q=</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">,</span> <span class="p">(</span><span class="nx">resp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
        <span class="nx">resp</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">data</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">data</span> <span class="o">+=</span> <span class="nx">chunk</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="nx">resp</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">here is the cb1 result </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">);</span>
            <span class="nx">cbCountGitUser</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}).</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">cbCountGitUser</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">response</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">response</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">response</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">here is the cb2 result </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">response</span><span class="p">.</span><span class="nx">total_count</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">cbGetGitUser</span><span class="p">(</span><span class="dl">"</span><span class="s2">limeii</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>
<p>在<code class="language-plaintext highlighter-rouge">cbGetGitUser</code>里先调用API，等拿到用户搜索结果之后，再调用回调函数<code class="language-plaintext highlighter-rouge">cbCountGitUser</code>计算搜索结果的用户数量。现在是只有一个回调函数，代码结构看起来还可以，假如回调函数特别多，加上中间还需要调用其他方法，就会有<code class="language-plaintext highlighter-rouge">callback hell</code>问题，整个代码结构横向发展，代码可读性差，而且很容易出错。</p>

<h2 id="promise">Promise</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">https</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">https</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">getGitUser</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">https</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://api.github.com/search/users?q=</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span><span class="p">,</span> <span class="p">(</span><span class="nx">resp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="dl">""</span><span class="p">;</span>
            <span class="nx">resp</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">data</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="nx">data</span> <span class="o">+=</span> <span class="nx">chunk</span><span class="p">;</span>
            <span class="p">});</span>
            <span class="nx">resp</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="nx">resolve</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
            <span class="p">});</span>
        <span class="p">}).</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Error</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
            <span class="nx">reject</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">countGitUser</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">response</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">response</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">response</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">total_count</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">here is the data: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">response</span><span class="p">);</span>
            <span class="nx">reject</span><span class="p">(</span><span class="dl">'</span><span class="s1">cannot get the user information!!!</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>


<span class="nx">getGitUser</span><span class="p">(</span><span class="dl">'</span><span class="s1">limeii</span><span class="dl">'</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the first promise </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">countGitUser</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the second promise </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">has error: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>
<p>在回调函数之后，JS引入了Promise，相对回调函数横向代码结构，Promise的代码结构是纵向发展的，每一个回调都是放在then里执行，代码可读性要好不少，不会有<code class="language-plaintext highlighter-rouge">callback hell</code>。但是由于Promise是一次性的，而且一旦创建Promise就不能取消也不能暂停，只能等待成功或者失败的结果，没办法在Promise的中间加入业务逻辑处理。</p>

<h2 id="generator">Generator</h2>
<p>下面示例代码中的<code class="language-plaintext highlighter-rouge">getGitUser</code>和<code class="language-plaintext highlighter-rouge">countGitUser</code>方法，共用Promise示例代码中的方法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">getGitUser</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="k">yield</span> <span class="nx">countGitUser</span><span class="p">(</span><span class="nx">result1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="nx">gen</span><span class="p">(</span><span class="dl">'</span><span class="s1">limeii</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the first yeild: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">g</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">res</span><span class="p">).</span><span class="nx">value</span><span class="p">;</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the second yeild: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">has error: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>
<p>在ES6引入了Generator，Generator相对Promise来说，通过<code class="language-plaintext highlighter-rouge">yield</code>关键字可以暂停异步代码，通过<code class="language-plaintext highlighter-rouge">next</code>方法重新恢复异步代码执行。从上面的示例代码可以看到执行两个<code class="language-plaintext highlighter-rouge">yield</code>，Generator的执行代码里有四个then，如果有很多个<code class="language-plaintext highlighter-rouge">yield</code>，Generator的执行代码里会有一大串then，执行代码看起来很冗余。</p>

<p>TJ Holowaychuk写过一个工具【<a href="https://github.com/tj/co">co</a>】，用于Generator的自执行。使用这个工具，上面那一串的执行代码，只用一行就可以了：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span><span class="o">*</span> <span class="nx">gen_co</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result1</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">getGitUser</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the first co </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">result1</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">result2</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">countGitUser</span><span class="p">(</span><span class="nx">result1</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the second co </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">result2</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">co</span><span class="p">(</span><span class="nx">gen_co</span><span class="p">(</span><span class="dl">'</span><span class="s1">limeii</span><span class="dl">'</span><span class="p">));</span>
</code></pre></div></div>
<p>co还是有一定的局限性，在<code class="language-plaintext highlighter-rouge">yield</code>命令后面只能是：</p>
<ul>
  <li>promises</li>
  <li>thunks (functions)</li>
  <li>array (parallel execution)</li>
  <li>objects (parallel execution)</li>
  <li>generators (delegation)</li>
  <li>generator functions (delegation)</li>
</ul>

<p>需要注意的是执行<code class="language-plaintext highlighter-rouge">yield</code>是没有返回值的，也就是每次返回值是<code class="language-plaintext highlighter-rouge">undefined</code>，在<code class="language-plaintext highlighter-rouge">next</code>方法里可以传入参数，作为上一次<code class="language-plaintext highlighter-rouge">yield</code>的返回结果。关于Generator的具体语法可以参考阮一峰的【<a href="http://es6.ruanyifeng.com/#docs/generator">Generator 函数的语法</a>】。</p>

<h2 id="async">Async</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">asyncFuc</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value1</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getGitUser</span><span class="p">(</span><span class="dl">"</span><span class="s2">limeii</span><span class="dl">"</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">value2</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">countGitUser</span><span class="p">(</span><span class="nx">value1</span><span class="p">);</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the first await value </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value1</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">the second await value </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">value2</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">asyncFuc</span><span class="p">();</span>
</code></pre></div></div>
<p>之前提到过Generator的执行代码非常长，虽然有【<a href="https://github.com/tj/co">co</a>】可以简化Generator的执行代码，但是co可以支持的对象有限。在ES7引入了Async，它其实就是Generator的语法糖，同样也简化了Generator的自执行。相对于co来说，Async的Await命令后面可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。而且Async的异步代码结构跟同步代码结构没有什么差异，可读性最好。</p>

<p>Async相对于Generator的语法来说，就是把星号（*）改为了<code class="language-plaintext highlighter-rouge">async</code>，<code class="language-plaintext highlighter-rouge">yield</code>改成了<code class="language-plaintext highlighter-rouge">await</code>，具体语法和用法可以参考阮一峰的【<a href="http://es6.ruanyifeng.com/#docs/async">async 函数</a>】。</p>

<h2 id="总结">总结</h2>
<p>在JS中，异步处理方式有回调函数、Promise、Generator、Async这四种方式。那么：</p>

<h3 id="async-会取代-generator-吗">async 会取代 Generator 吗？</h3>
<p>Generator本来是用作生成器，使用Generator处理异步请求只是一个比较hack的用法，在异步方面，async可以取代Generator，但是async和Generator两个语法本身是用来解决不同的问题的。</p>

<h3 id="async-会取代-promise-吗">async 会取代 Promise 吗？</h3>
<ul>
  <li>async函数返回一个Promise对象</li>
  <li>面对复杂的异步流程，Promise提供的all和race会更加好用</li>
  <li>Promise本身就是一个对象，在代码里可以任意传递</li>
  <li>async的支持率还是很低，即使有Babel，编译后也要增加一千行左右代码</li>
</ul>
:ET