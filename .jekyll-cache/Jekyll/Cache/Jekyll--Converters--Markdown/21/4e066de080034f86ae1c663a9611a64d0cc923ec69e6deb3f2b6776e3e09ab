I""<p>在上一篇文章【<a href="https://limeii.github.io/2019/05/js-lexical-environment/">JS：深入理解JavaScript-词法环境</a>】详细介绍了词法环境，它是在V8引擎词法分析阶段用来登记变量的，这样在引擎真正执行代码的时候，就知道去哪里拿变量的值。也提到过，每次执行回调函数的时候，会把方法以<code class="language-plaintext highlighter-rouge">执行上下文（Execution Context）</code>的方式压入<code class="language-plaintext highlighter-rouge">执行栈（Call Stack）</code>，执行完以后会被弹出执行栈。</p>

<p>比如有代码：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hi, i am foo</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="nx">baz</span><span class="p">();</span>
</code></pre></div></div>
<p>整个代码执行过程如下：</p>

<p><img src="/assets/images/posts/js/js-execution-context01.png" alt="js-execution-context" height="100%" width="100%" /></p>

<p>图中的蓝色方块就是<code class="language-plaintext highlighter-rouge">执行上下文（Execution Context）</code>，包在蓝色方块的灰色区域就是<code class="language-plaintext highlighter-rouge">执行栈（Call Stack）</code>，整个执行栈遵循后进先出的原则：</p>
<ul>
  <li>在开始执行任何代码之前，都会创建全局上下文压入栈底。</li>
  <li>创建词法环境，登记变量声明和函数声明。</li>
  <li>引擎运行到<code class="language-plaintext highlighter-rouge">baz()</code>的时候，把<code class="language-plaintext highlighter-rouge">baz执行上下文</code>压入执行栈。</li>
  <li><code class="language-plaintext highlighter-rouge">baz</code>调用<code class="language-plaintext highlighter-rouge">foo</code>，把<code class="language-plaintext highlighter-rouge">foo执行上下文</code>压入执行栈顶。</li>
  <li><code class="language-plaintext highlighter-rouge">foo</code>调用<code class="language-plaintext highlighter-rouge">console.log</code>,把<code class="language-plaintext highlighter-rouge">console.log执行上下文</code>压入执行栈顶。</li>
  <li><code class="language-plaintext highlighter-rouge">console.log执行上下文</code>是当前正在运行的执行上下文，在console执行完以后，<code class="language-plaintext highlighter-rouge">console.log执行上下文</code>被弹出执行栈。</li>
  <li><code class="language-plaintext highlighter-rouge">foo执行上下文</code>是当前正在运行的执行上下文，在foo执行完以后，<code class="language-plaintext highlighter-rouge">foo执行上下文</code>被弹出执行栈。</li>
  <li><code class="language-plaintext highlighter-rouge">baz执行上下文</code>是当前正在运行的执行上下文，在baz执行完以后，<code class="language-plaintext highlighter-rouge">baz执行上下文</code>被弹出执行栈。</li>
</ul>

<p>那么只有function代码可以放到执行栈中运行吗？具体执行栈里有什么，它是怎么工作的呢？</p>

<h2 id="可执行代码executable-code">可执行代码（Executable Code）</h2>
<p>事实上不仅仅是function可以作为执行上下文在执行栈中运行，在JS里定义了四种可执行代码：</p>
<ul>
  <li>global code：整个js文件。</li>
  <li>function code：函数代码。</li>
  <li>module：模块代码</li>
  <li>eval code：放在eval的代码。</li>
</ul>

<p>执行上下文（Execution Context）有三个组成部分：</p>
<ul>
  <li><strong>LexicalEnvironment</strong>：是一个词法环境(Lexical Environment)。</li>
  <li><strong>VariableEnvironment</strong>：也是一个词法环境(Lexical Environment)，一般和LexicalEnvironment指向同一个词法环境。</li>
  <li><strong>ThisBinding</strong>：这个就是代码里常用的this。</li>
</ul>

<h2 id="代码执行">代码执行</h2>
<p>JS引擎是按照可执行代码来执行代码的，每次执行步骤如下：</p>
<ul>
  <li>1：创建一个新的<strong>执行上下文（Execution Context）</strong></li>
  <li>2：创建一个新的<strong>词法环境（Lexical Environment）</strong></li>
  <li>3：把<strong>LexicalEnvironment</strong>和<strong>VariableEnvironment</strong>指向新创建的词法环境</li>
  <li>4：把这个执行上下文压入<strong>执行栈</strong>并成为<strong>正在运行的执行上下文</strong></li>
  <li>5：执行代码</li>
  <li>6：执行结束后，把这个执行上下文弹出执行栈</li>
</ul>

<p>前面的代码在执行完1-4步以后，整个环境看起来是这样的：
<img src="/assets/images/posts/js/js-execution-context02.png" alt="js-execution-context" height="100%" width="100%" /></p>
<blockquote>
<p>
每个function都会新创建一个词法环境，function的词法环境中的scope，就是词法环境中的outer，作用域链就是沿着outer往上一层的词法环境里找变量/方法。
</p>
</blockquote>

<p>执行第五步，会先给变量<code class="language-plaintext highlighter-rouge">a</code>赋值，然后执行<code class="language-plaintext highlighter-rouge">console.log(a)</code>:
<img src="/assets/images/posts/js/js-execution-context03.png" alt="js-execution-context" height="100%" width="100%" /></p>

<p>执行第六步，<code class="language-plaintext highlighter-rouge">foo</code> <code class="language-plaintext highlighter-rouge">baz</code>执行完后被弹出执行栈，这两个function对象还在内存中，等待垃圾回收。
<img src="/assets/images/posts/js/js-execution-context04.png" alt="js-execution-context" height="100%" width="100%" /></p>

<h2 id="为什么要有两个词法环境lexicalenvironment和variableenvironment">为什么要有两个词法环境：LexicalEnvironment和VariableEnvironment</h2>

<p><strong>变量环境组件（VariableEnvironment）</strong>是用来登记<code class="language-plaintext highlighter-rouge">var</code> <code class="language-plaintext highlighter-rouge">function</code>变量声明，<strong>词法环境组件（LexicalEnvironment）</strong>是用来登记<code class="language-plaintext highlighter-rouge">let</code> <code class="language-plaintext highlighter-rouge">const</code> <code class="language-plaintext highlighter-rouge">class</code>等变量声明。</p>

<p>在ES6之前都没有块级作用域，ES6之后我们可以用<code class="language-plaintext highlighter-rouge">let</code> <code class="language-plaintext highlighter-rouge">const</code>来声明块级作用域，有这两个词法环境是为了实现块级作用域的同时不影响<code class="language-plaintext highlighter-rouge">var</code>变量声明和函数声明，具体如下：</p>

<ul>
  <li>1：首先在一个正在运行的执行上下文内，词法环境由LexicalEnvironment和VariableEnvironment构成，用来登记所有的变量声明。</li>
  <li>2：当执行到块级代码时候，会先LexicalEnvironment记录下来，记录为oldEnv。</li>
  <li>3：创建一个新的LexicalEnvironment（outer指向oldEnv），记录为newEnv，并将newEnv设置为正在执行上下文的LexicalEnvironment。</li>
  <li>4：块级代码内的<code class="language-plaintext highlighter-rouge">let</code> <code class="language-plaintext highlighter-rouge">const</code>会登记在newEnv里面，但是<code class="language-plaintext highlighter-rouge">var</code>声明和函数声明还是登记在原来的VariableEnvironment里。</li>
  <li>5：块级代码执行结束后，将oldEnv还原为正在执行上下文的LexicalEnvironment。</li>
</ul>

<blockquote>
<p>
<font color="red">
块级代码内的函数声明会被当做var声明，会被提升至外部环境，块级代码运行前其值为初始值undefined。
</font>
</p>
</blockquote>

<p>在这篇文章里介绍了执行上下文，它由三部分组成：LexicalEnvironment、VariableEnvironment和ThisBinding，并详细介绍了LexicalEnvironment和VariableEnvironment，在文章【<a href="https://limeii.github.io/2019/05/js-this/">JS：深入理解JavaScript-this</a>】会详细介绍this。</p>
:ET