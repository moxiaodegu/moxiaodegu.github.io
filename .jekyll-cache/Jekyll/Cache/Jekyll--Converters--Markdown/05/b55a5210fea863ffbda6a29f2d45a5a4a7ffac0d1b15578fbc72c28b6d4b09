I".<p>在文章【<a href="https://limeii.github.io/2019/05/js-execution-context/">JS：深入理解JavaScript-执行上下文</a>】中介绍了代码在执行栈是如何运行的，假设有如下代码：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span>
</code></pre></div></div>

<p>引擎在执行这段代码的步骤如下：</p>
<ul>
  <li>1：创建一个新的<strong>执行上下文（Execution Context）</strong></li>
  <li>2：创建一个新的<strong>词法环境（Lexical Environment）</strong></li>
  <li>3：把<strong>LexicalEnvironment</strong>和<strong>VariableEnvironment</strong>指向新创建的词法环境</li>
  <li>4：把这个执行上下文压入<strong>执行栈</strong>并成为<strong>正在运行的执行上下文</strong></li>
  <li>5：执行代码</li>
  <li>6：执行结束后，把这个执行上下文弹出执行栈</li>
</ul>

<p>代码在执行完1-4步以后，整个环境看起来是这样的：</p>

<p><img src="/assets/images/posts/js/js-closures01.png" alt="js-closures" height="100%" width="100%" /></p>

<p>执行第五步，执行到foo会先给变量<code class="language-plaintext highlighter-rouge">a</code>赋值，然后给bar方法创建一个新的执行上下文，然后再执行<code class="language-plaintext highlighter-rouge">console.log(a)</code>:</p>

<p><img src="/assets/images/posts/js/js-closures02.png" alt="js-closures" height="100%" width="100%" /></p>

<p>执行第六步，<code class="language-plaintext highlighter-rouge">foo</code> <code class="language-plaintext highlighter-rouge">bar</code>执行完后被弹出执行栈，这两个function对象（红色区域1和2）还在内存中，等待垃圾回收。</p>

<p><img src="/assets/images/posts/js/js-closures03.png" alt="js-closures" height="100%" width="100%" /></p>

<p>在执行完上面的代码以后，可以看到<code class="language-plaintext highlighter-rouge">foo</code> <code class="language-plaintext highlighter-rouge">bar</code>的词法环境访问链路断掉了，虽然它们还在内存了（红色区域1和2），但是我们再也没办法访问这两个词法环境里的变量。</p>

<p>这时候如果还想访问<code class="language-plaintext highlighter-rouge">foo</code> <code class="language-plaintext highlighter-rouge">bar</code>的词法环境，比如还想用a的值，我们把代码改一下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>

<span class="nx">baz</span><span class="p">();</span>
</code></pre></div></div>

<p>运行<code class="language-plaintext highlighter-rouge">baz()</code>会输出2（2是foo词法环境里的值），也就是变量a在foo词法环境之外被访问了，这就是<strong>闭包</strong>。</p>

<p>正常情况下，在方法foo执行完以后，foo的执行上下文被弹出执行栈，它的词法环境链路也就失联了。我们知道每个方法在执行的时候都会创建一个新的执行上下文，同时也会创建它们自己的词法环境，每个方法的词法环境里有一个<code class="language-plaintext highlighter-rouge">scope</code>会保存（指向）它上一层的词法环境。 那么foo方法执行完以后返回bar，这个bar的scope里还保留着整个foo方法的词法环境，那么在执行<code class="language-plaintext highlighter-rouge">baz()</code>的时候也就是执行<code class="language-plaintext highlighter-rouge">bar()</code>，这样就可以访问失联的<code class="language-plaintext highlighter-rouge">foo方法的词法作用域</code>，也就是可以拿到变量<code class="language-plaintext highlighter-rouge">a</code>的值。</p>

<p><strong>闭包</strong>就是指：执行完的<code class="language-plaintext highlighter-rouge">执行上下文</code>被弹出执行栈，它的词法环境处于失联状态，后续的执行上下文没办法直接访问这个失联的词法环境。在这种情况下还保留了对那个词法环境的<code class="language-plaintext highlighter-rouge">引用</code>，从而可以通过这个<code class="language-plaintext highlighter-rouge">引用</code>去访问失联的词法环境，这个<code class="language-plaintext highlighter-rouge">引用</code>就是闭包。</p>

<p>其实我们每天写的代码，基本会用到闭包，JS也有很多闭包的应用有以下几种方式：</p>

<ul>
  <li>第一种：
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

      <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nx">bar</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">();</span>

      <span class="nx">baz</span><span class="p">();</span> <span class="c1">// closure!</span>
</code></pre></div>    </div>
  </li>
  <li>第二种：
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

      <span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span> <span class="c1">// 2</span>
      <span class="p">}</span>

      <span class="nx">bar</span><span class="p">(</span> <span class="nx">baz</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">fn</span><span class="p">();</span> <span class="c1">// closure!</span>
      <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>第三种：
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="kd">var</span> <span class="nx">fn</span><span class="p">;</span>

      <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

          <span class="kd">function</span> <span class="nx">baz</span><span class="p">()</span> <span class="p">{</span>
              <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">a</span> <span class="p">);</span>
          <span class="p">}</span>

          <span class="nx">fn</span> <span class="o">=</span> <span class="nx">baz</span><span class="p">;</span> <span class="c1">// assign `baz` to global variable</span>
      <span class="p">}</span>

      <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">fn</span><span class="p">();</span> <span class="c1">// closure!</span>
      <span class="p">}</span>

      <span class="nx">foo</span><span class="p">();</span>

      <span class="nx">bar</span><span class="p">();</span> <span class="c1">// 2</span>
</code></pre></div>    </div>
  </li>
  <li>第四种：
    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">wait</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>

      <span class="nx">setTimeout</span><span class="p">(</span> <span class="kd">function</span> <span class="nx">timer</span><span class="p">(){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">message</span> <span class="p">);</span>
      <span class="p">},</span> <span class="mi">1000</span> <span class="p">);</span>

  <span class="p">}</span>

  <span class="nx">wait</span><span class="p">(</span> <span class="dl">"</span><span class="s2">Hello, closure!</span><span class="dl">"</span> <span class="p">);</span> <span class="c1">// 打印出 hello closure！ 回调函数的message是wait方法作用域的值。</span>
</code></pre></div>    </div>

    <p>需要注意的是，如果代码写成这样：</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">wait</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>

      <span class="nx">setTimeout</span><span class="p">(</span> <span class="kd">function</span> <span class="nx">timer</span><span class="p">(){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">message</span> <span class="p">);</span>
      <span class="p">},</span> <span class="mi">1000</span> <span class="p">);</span>

  <span class="p">}</span>

  <span class="nx">wait</span><span class="p">(</span> <span class="dl">"</span><span class="s2">Hello, closure!</span><span class="dl">"</span> <span class="p">);</span> <span class="c1">// 打印出undefined, 回调函数的this值的是全局变量，全局变量没有这个值，所以是undefined。</span>
</code></pre></div>    </div>
  </li>
  <li>第五种是模块化</li>
</ul>
:ET