I"<p>在文章【<a href="https://limeii.github.io/2019/05/js-prototype/">JS：深入理解JavaScript-原型</a>】详细介绍了原型和<code class="language-plaintext highlighter-rouge">new</code> <code class="language-plaintext highlighter-rouge">Object.create()</code>在创建对象和实现继承的区别。JS的继承是基于原型（prototype）实现的，再理解原型之后，就很容易理解JS的继承方式了。</p>

<p>在这篇文章里将会详细介绍6中常见的JS继承方式。</p>

<h2 id="1-原型继承">1. 原型继承</h2>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">Animal</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">category</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">category</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">category</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">breed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">black</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Cat</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">cat1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">kitty</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">cat2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">hua</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">,</span> <span class="nx">cat2</span><span class="p">);</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/js/js-inheritance01.png" alt="js-inheritance" height="100%" width="100%" /></p>

<p>这种方式把子类的原型指向了<strong>父类的实例</strong>，所以<strong>子类的实例可以通过原型链访问到父类的实例<code class="language-plaintext highlighter-rouge">new Animial()</code>，然后通过原型链向上可以访问到<code class="language-plaintext highlighter-rouge">Animal.prototype</code></strong>，就可以实现子类实例可以继承和访问父类的属性和方法。</p>

<p>这种方式的原型链如下：
<img src="/assets/images/posts/js/js-inheritance02.png" alt="js-inheritance" height="100%" width="100%" /></p>

<p>我们都知道在操作基本数据类的时候操作的是值，在操作引用数据类型的时候操作的是引用地址，那么在cat1中更改breed属性的值，会同时影响cat2中这个属性的值，如下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nx">cat1</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">150</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">.</span><span class="nx">price</span><span class="p">);</span><span class="c1">//150</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat2</span><span class="p">.</span><span class="nx">price</span><span class="p">);</span><span class="c1">//100</span>

<span class="nx">cat1</span><span class="p">.</span><span class="nx">breed</span><span class="p">.</span><span class="nx">color</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">white</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">.</span><span class="nx">breed</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span><span class="c1">//white</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat2</span><span class="p">.</span><span class="nx">breed</span><span class="p">.</span><span class="nx">color</span><span class="p">);</span><span class="c1">//white cat2的bredd属性也会跟着变化</span>
</code></pre></div></div>

<p>优点：</p>
<ul>
  <li>父类/父类原型新增的属性和方法，子类都可以访问</li>
  <li>简单，易于实现</li>
</ul>

<p>缺点：</p>
<ul>
  <li>无法实现多继承</li>
  <li>原型对象的引用属性都被多个实例共享，不管是私有还是公有属性</li>
  <li>创建子类实例，无法像父类构造函数传参</li>
  <li>想要为子类原型新增属性和方法，必须要在<code class="language-plaintext highlighter-rouge">Cat.prototype = new Animal()</code>之后执行，不能放在构造器中</li>
</ul>

<h2 id="2-借用构造函数继承经典继承">2. 借用构造函数继承（经典继承）</h2>
<p>这种方式的关键在于，在子类的构造函数中通过call()调用父类的构造函数。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">category</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">category</span> <span class="o">=</span> <span class="nx">category</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">others</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">other1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="na">other2</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">set category</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">category</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">breed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">black</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Cat</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">Animal</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>


<span class="kd">var</span> <span class="nx">cat1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">kitty</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">cat2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">hua</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">,</span> <span class="nx">cat2</span><span class="p">);</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/js/js-inheritance03.png" alt="js-inheritance" height="100%" width="100%" /></p>

<p>在执行<code class="language-plaintext highlighter-rouge">var cat1 = new Cat("kitty")</code>的时候，子类构造函数<code class="language-plaintext highlighter-rouge">Cat</code>中的<code class="language-plaintext highlighter-rouge">this</code>指的是<code class="language-plaintext highlighter-rouge">cat1</code>这个实例对象，<code class="language-plaintext highlighter-rouge">cat1</code>这个实例对象继承了父类<code class="language-plaintext highlighter-rouge">Animal</code>中的属性和方法，但是不能访问<code class="language-plaintext highlighter-rouge">Animal.prototype</code>中的属性和方法，<code class="language-plaintext highlighter-rouge">cat2</code>也是同理。</p>

<p>原型链关系图如下：
<img src="/assets/images/posts/js/js-inheritance04.png" alt="js-inheritance" height="100%" width="100%" /></p>

<p>子类实例cat1和cat2可以继承Cat.prototype和Animal的属性和方法，但是不能访问Animal.prototype的属性和方法，如下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cat1</span><span class="p">.</span><span class="nx">getCategory</span><span class="p">();</span><span class="c1">//Uncaught TypeError: cat1.getCategory is not a function</span>
<span class="nx">cat1</span><span class="p">.</span><span class="nx">price</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p>子类实例cat1和cat2从父类Animal那继承的属性和方法不共享，在各自的内存中有一份独立的，如下：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">cat1</span><span class="p">.</span><span class="nx">others</span><span class="p">.</span><span class="nx">other1</span><span class="o">=</span><span class="mi">123</span><span class="err">；</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">.</span><span class="nx">others</span><span class="p">.</span><span class="nx">other1</span><span class="p">);</span><span class="c1">//123</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat2</span><span class="p">.</span><span class="nx">others</span><span class="p">.</span><span class="nx">other1</span><span class="p">);</span><span class="c1">//1</span>
</code></pre></div></div>

<p>优点：</p>
<ul>
  <li>解决了原型链中子类实例共享父类引用属性的问题</li>
  <li>创建子类实例，可以向父类传递参数</li>
  <li>可以实现多继承（call多个父类对象）</li>
</ul>

<p>缺点：</p>
<ul>
  <li>实例并不是父类的实例，只是子类的实例</li>
  <li>只能继承父类的实例属性和方法，不能继承父类原型属性和方法</li>
  <li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>

<h2 id="3-原型链借用构造函数的组合继承">3. 原型链+借用构造函数的组合继承</h2>

<p>这种方式的关键是：通过调用父类构造函数，继承父类的属性并且可以向父类传递参数，然后再通过将父类实例作为子类原型，实现函数复用。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">category</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">category</span> <span class="o">=</span> <span class="nx">category</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">others</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">other1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="na">other2</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">set category</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">category</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">breed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">black</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Cat</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">Animal</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">();</span>
<span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">=</span> <span class="nx">Cat</span><span class="p">;</span><span class="c1">//组合方式需要修复构造函数指向</span>

<span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>

<span class="kd">var</span> <span class="nx">cat1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">kitty</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">);</span>
</code></pre></div></div>
<p><img src="/assets/images/posts/js/js-inheritance05.png" alt="js-inheritance" height="100%" width="100%" /></p>

<p>这种方式的原型链关系和原型继承是一样的：
<img src="/assets/images/posts/js/js-inheritance02.png" alt="js-inheritance" height="100%" width="100%" /></p>

<p>与原型继承不同在于：通过在子类构造函数通过call()调用父类的构造函数，可以向父类构造函数传递参数，并且不会共享父类中引用属性的值，如下：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cat1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">kitty</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">cat2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">hua</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">cat1</span><span class="p">.</span><span class="nx">others</span><span class="p">.</span><span class="nx">other1</span><span class="o">=</span><span class="mi">123</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">.</span><span class="nx">others</span><span class="p">.</span><span class="nx">other1</span><span class="p">);</span><span class="c1">//123</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat2</span><span class="p">.</span><span class="nx">others</span><span class="p">.</span><span class="nx">other1</span><span class="p">);</span><span class="c1">//1</span>
</code></pre></div></div>
<p>这种方法结合了原型继承和借用构造函数继承的优点，是JS中最常用的继承模式，不过也存在缺点，就是无论在什么时候都会调用两次父类构造函数：</p>

<p>一次是设置子类型实例的原型的时候：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span> <span class="k">new</span> <span class="nx">Animal</span><span class="p">();</span>
</code></pre></div></div>
<p>一次在创建子类型实例的时候：</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">cat1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">kitty</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// Parent.call(this, name);</span>
</code></pre></div></div>

<p>优点：</p>

<ul>
  <li>可以继承父类的属性和方法，也可以继承父类原型的属性和方法</li>
  <li>不存在引用属性共享问题</li>
  <li>可以传参给父类构造函数</li>
  <li>函数可以复用</li>
</ul>

<p>缺点：</p>

<ul>
  <li>调用了两次构造函数，生成了两份实例</li>
</ul>

<h2 id="4-原型式继承">4. 原型式继承</h2>

<p>通过<code class="language-plaintext highlighter-rouge">Object.create</code>，将出入的第一个参数作为创建对象的原型。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">category</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">category</span> <span class="o">=</span> <span class="nx">category</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">others</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">other1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="na">other2</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">set category</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">category</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">breed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">black</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">animal1</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Animal</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">animal2</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">Animal</span><span class="p">);</span>

</code></pre></div></div>
<p>优点：</p>

<ul>
  <li>父类/父类原型新增的属性和方法，子类都可以访问</li>
  <li>简单，易于实现</li>
</ul>

<p>缺点：</p>

<ul>
  <li>无法实现多继承</li>
  <li>原型对象的引用属性都被多有实例共享，不管是私有还是公有属性</li>
  <li>创建子类实例，无法像父类构造函数传参</li>
</ul>

<h2 id="5-寄生式继承">5. 寄生式继承</h2>
<p>创建一个尽用于封装过程的函数，该函数在内部以某种形式做增强对象，最后返回对象。</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createObj</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hi</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>缺点：跟借用构造函数模式一样，无法实现函数复用，每次创建对象都会创建一遍方法。</p>

<h2 id="6-寄生组合式继承">6. 寄生组合式继承</h2>
<p>在原型链+借用构造函数的组合继承这种方式中，最大的缺点就是会调用两次父类的构造函数，那可不可以避免一次重复调用呢？</p>

<p>不使用<code class="language-plaintext highlighter-rouge">Cat.prototype = new Animal()</code>，而是间接就让Cat.prototype访问Animal.prototyoe呢？</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Animal</span><span class="p">(</span><span class="nx">category</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">category</span> <span class="o">=</span> <span class="nx">category</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">others</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">other1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="na">other2</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">};</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">set category</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getCategory</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">category</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">breed</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">black</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">Cat</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">Animal</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="dl">"</span><span class="s2">cat</span><span class="dl">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">F</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">//核心代码</span>
<span class="nx">F</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nx">Animal</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span> <span class="c1">//核心代码</span>

<span class="nx">Cat</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">F</span><span class="p">();</span>

<span class="kd">var</span> <span class="nx">cat1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cat</span><span class="p">(</span><span class="dl">"</span><span class="s2">kitty</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">cat1</span><span class="p">);</span>
</code></pre></div></div>

:ET